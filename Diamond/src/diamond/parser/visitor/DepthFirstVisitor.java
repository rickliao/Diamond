//
// Generated by JTB 1.3.2
//

package diamond.parser.visitor;

import diamond.parser.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class DepthFirstVisitor implements Visitor {

    //
    // Auto class visitors--probably don't need to be overridden.
    //
    @Override
    public void visit(NodeList n) {
        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();)
            e.nextElement().accept(this);
    }

    @Override
    public void visit(NodeListOptional n) {
        if (n.present())
            for (Enumeration<Node> e = n.elements(); e.hasMoreElements();)
                e.nextElement().accept(this);
    }

    @Override
    public void visit(NodeOptional n) {
        if (n.present())
            n.node.accept(this);
    }

    @Override
    public void visit(NodeSequence n) {
        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();)
            e.nextElement().accept(this);
    }

    @Override
    public void visit(NodeToken n) {
    }

    //
    // User-generated visitor methods below
    //

    /**
     * prologue -> Prologue() nodeChoice -> ( SelectQuery() | ConstructQuery() |
     * DescribeQuery() | AskQuery() )
     */
    @Override
    public void visit(Query n) {
        n.prologue.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * nodeOptional -> ( BaseDecl() )? nodeListOptional -> ( PrefixDecl() )*
     */
    @Override
    public void visit(Prologue n) {
        n.nodeOptional.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * nodeToken -> <BASE> nodeToken1 -> <IRI_REF>
     */
    @Override
    public void visit(BaseDecl n) {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * nodeToken -> <PREFIX> nodeToken1 -> <PNAME_NS> nodeToken2 -> <IRI_REF>
     */
    @Override
    public void visit(PrefixDecl n) {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeToken2.accept(this);
    }

    /**
     * nodeToken -> <SELECT> nodeOptional -> ( <DISTINCT> | <REDUCED> )?
     * nodeChoice -> ( ( Var() )+ | "*" ) nodeListOptional -> ( DatasetClause()
     * )* whereClause -> WhereClause() solutionModifier -> SolutionModifier()
     */
    @Override
    public void visit(SelectQuery n) {
        n.nodeToken.accept(this);
        n.nodeOptional.accept(this);
        n.nodeChoice.accept(this);
        n.nodeListOptional.accept(this);
        n.whereClause.accept(this);
        n.solutionModifier.accept(this);
    }

    /**
     * nodeToken -> <CONSTRUCT> constructTemplate -> ConstructTemplate()
     * nodeListOptional -> ( DatasetClause() )* whereClause -> WhereClause()
     * solutionModifier -> SolutionModifier()
     */
    @Override
    public void visit(ConstructQuery n) {
        n.nodeToken.accept(this);
        n.constructTemplate.accept(this);
        n.nodeListOptional.accept(this);
        n.whereClause.accept(this);
        n.solutionModifier.accept(this);
    }

    /**
     * nodeToken -> <DESCRIBE> nodeChoice -> ( ( VarOrIRIref() )+ | "*" )
     * nodeListOptional -> ( DatasetClause() )* nodeOptional -> ( WhereClause()
     * )? solutionModifier -> SolutionModifier()
     */
    @Override
    public void visit(DescribeQuery n) {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        n.nodeListOptional.accept(this);
        n.nodeOptional.accept(this);
        n.solutionModifier.accept(this);
    }

    /**
     * nodeToken -> <ASK> nodeListOptional -> ( DatasetClause() )* whereClause
     * -> WhereClause()
     */
    @Override
    public void visit(AskQuery n) {
        n.nodeToken.accept(this);
        n.nodeListOptional.accept(this);
        n.whereClause.accept(this);
    }

    /**
     * nodeToken -> <FROM> nodeChoice -> ( DefaultGraphClause() |
     * NamedGraphClause() )
     */
    @Override
    public void visit(DatasetClause n) {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * sourceSelector -> SourceSelector()
     */
    @Override
    public void visit(DefaultGraphClause n) {
        n.sourceSelector.accept(this);
    }

    /**
     * nodeToken -> <NAMED> sourceSelector -> SourceSelector()
     */
    @Override
    public void visit(NamedGraphClause n) {
        n.nodeToken.accept(this);
        n.sourceSelector.accept(this);
    }

    /**
     * iRIref -> IRIref()
     */
    @Override
    public void visit(SourceSelector n) {
        n.iRIref.accept(this);
    }

    /**
     * nodeOptional -> ( <WHERE> )? groupGraphPattern -> GroupGraphPattern()
     */
    @Override
    public void visit(WhereClause n) {
        n.nodeOptional.accept(this);
        n.groupGraphPattern.accept(this);
    }

    /**
     * nodeOptional -> ( OrderClause() )? nodeOptional1 -> (
     * LimitOffsetClauses() )?
     */
    @Override
    public void visit(SolutionModifier n) {
        n.nodeOptional.accept(this);
        n.nodeOptional1.accept(this);
    }

    /**
     * nodeChoice -> ( LimitClause() ( OffsetClause() )? | OffsetClause() (
     * LimitClause() )? )
     */
    @Override
    public void visit(LimitOffsetClauses n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> <ORDER> nodeToken1 -> <BY> nodeList -> ( OrderCondition() )+
     */
    @Override
    public void visit(OrderClause n) {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeList.accept(this);
    }

    /**
     * nodeChoice -> ( ( <ASC> | <DESC> ) BrackettedExpression() ) | (
     * Constraint() | Var() )
     */
    @Override
    public void visit(OrderCondition n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> <LIMIT> nodeToken1 -> <INTEGER>
     */
    @Override
    public void visit(LimitClause n) {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * nodeToken -> <OFFSET> nodeToken1 -> <INTEGER>
     */
    @Override
    public void visit(OffsetClause n) {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * nodeToken -> "{" nodeOptional -> ( TriplesBlock() )? nodeListOptional ->
     * ( GraphPatternNotTriples() ( "." )? ( TriplesBlock() )? )* nodeToken1 ->
     * "}"
     */
    @Override
    public void visit(GroupGraphPattern n) {
        n.nodeToken.accept(this);
        n.nodeOptional.accept(this);
        n.nodeListOptional.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * triplesSameSubject -> TriplesSameSubject() nodeOptional -> ( "." (
     * TriplesBlock() )? )?
     */
    @Override
    public void visit(TriplesBlock n) {
        n.triplesSameSubject.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * nodeChoice -> OptionalGraphPattern() | GroupOrUnionGraphPattern() |
     * GraphGraphPattern() | Filter() | Bind()
     */
    @Override
    public void visit(GraphPatternNotTriples n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> <OPTIONAL> groupGraphPattern -> GroupGraphPattern()
     */
    @Override
    public void visit(OptionalGraphPattern n) {
        n.nodeToken.accept(this);
        n.groupGraphPattern.accept(this);
    }

    /**
     * nodeToken -> <GRAPH> varOrIRIref -> VarOrIRIref() groupGraphPattern ->
     * GroupGraphPattern()
     */
    @Override
    public void visit(GraphGraphPattern n) {
        n.nodeToken.accept(this);
        n.varOrIRIref.accept(this);
        n.groupGraphPattern.accept(this);
    }

    /**
     * groupGraphPattern -> GroupGraphPattern() nodeListOptional -> ( <UNION>
     * GroupGraphPattern() )*
     */
    @Override
    public void visit(GroupOrUnionGraphPattern n) {
        n.groupGraphPattern.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * nodeToken -> <FILTER> constraint -> Constraint()
     */
    @Override
    public void visit(Filter n) {
        n.nodeToken.accept(this);
        n.constraint.accept(this);
    }

    /**
     * nodeChoice -> BrackettedExpression() | BuiltInCall() | FunctionCall()
     */
    @Override
    public void visit(Constraint n) {
        n.nodeChoice.accept(this);
    }

    /**
     * iRIref -> IRIref() argList -> ArgList()
     */
    @Override
    public void visit(FunctionCall n) {
        n.iRIref.accept(this);
        n.argList.accept(this);
    }

    /**
     * nodeChoice -> ( <NIL> | "(" Expression() ( "," Expression() )* ")" )
     */
    @Override
    public void visit(ArgList n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> "{" nodeOptional -> ( ConstructTriples() )? nodeToken1 ->
     * "}"
     */
    @Override
    public void visit(ConstructTemplate n) {
        n.nodeToken.accept(this);
        n.nodeOptional.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * triplesSameSubject -> TriplesSameSubject() nodeOptional -> ( "." (
     * ConstructTriples() )? )?
     */
    @Override
    public void visit(ConstructTriples n) {
        n.triplesSameSubject.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * nodeChoice -> VarOrTerm() PropertyListNotEmpty() | TriplesNode()
     * PropertyList()
     */
    @Override
    public void visit(TriplesSameSubject n) {
        n.nodeChoice.accept(this);
    }

    /**
     * verb -> Verb() objectList -> ObjectList() nodeListOptional -> ( ";" (
     * Verb() ObjectList() )? )*
     */
    @Override
    public void visit(PropertyListNotEmpty n) {
        n.verb.accept(this);
        n.objectList.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * nodeOptional -> ( PropertyListNotEmpty() )?
     */
    @Override
    public void visit(PropertyList n) {
        n.nodeOptional.accept(this);
    }

    /**
     * sparqlObject -> SparqlObject() nodeListOptional -> ( "," SparqlObject()
     * )*
     */
    @Override
    public void visit(ObjectList n) {
        n.sparqlObject.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * graphNode -> GraphNode()
     */
    @Override
    public void visit(SparqlObject n) {
        n.graphNode.accept(this);
    }

    /**
     * nodeChoice -> VarOrIRIref() | <TYPE_A> | PutativeLiteral()
     */
    @Override
    public void visit(Verb n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> SparqlCollection() | BlankNodePropertyList()
     */
    @Override
    public void visit(TriplesNode n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> "[" propertyListNotEmpty -> PropertyListNotEmpty()
     * nodeToken1 -> "]"
     */
    @Override
    public void visit(BlankNodePropertyList n) {
        n.nodeToken.accept(this);
        n.propertyListNotEmpty.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * nodeToken -> "(" nodeList -> ( GraphNode() )+ nodeToken1 -> ")"
     */
    @Override
    public void visit(SparqlCollection n) {
        n.nodeToken.accept(this);
        n.nodeList.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * nodeChoice -> VarOrTerm() | TriplesNode()
     */
    @Override
    public void visit(GraphNode n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> Var() | GraphTerm()
     */
    @Override
    public void visit(VarOrTerm n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> Var() | IRIref()
     */
    @Override
    public void visit(VarOrIRIref n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <VAR1> | <VAR2>
     */
    @Override
    public void visit(Var n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> IRIref() | RDFLiteral() | NumericLiteral() |
     * BooleanLiteral() | BlankNode() | PutativeLiteral() | <NIL>
     */
    @Override
    public void visit(GraphTerm n) {
        n.nodeChoice.accept(this);
    }

    /**
     * conditionalOrExpression -> ConditionalOrExpression()
     */
    @Override
    public void visit(Expression n) {
        n.conditionalOrExpression.accept(this);
    }

    /**
     * conditionalAndExpression -> ConditionalAndExpression() nodeListOptional
     * -> ( "||" ConditionalAndExpression() )*
     */
    @Override
    public void visit(ConditionalOrExpression n) {
        n.conditionalAndExpression.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * valueLogical -> ValueLogical() nodeListOptional -> ( "&&" ValueLogical()
     * )*
     */
    @Override
    public void visit(ConditionalAndExpression n) {
        n.valueLogical.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * relationalExpression -> RelationalExpression()
     */
    @Override
    public void visit(ValueLogical n) {
        n.relationalExpression.accept(this);
    }

/**
     * numericExpression -> NumericExpression() nodeOptional -> ( "="
     * NumericExpression() | "!=" NumericExpression() | "<" NumericExpression()
     * | ">" NumericExpression() | "<=" NumericExpression() | ">="
     * NumericExpression() )?
     */
    @Override
    public void visit(RelationalExpression n) {
        n.numericExpression.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * additiveExpression -> AdditiveExpression()
     */
    @Override
    public void visit(NumericExpression n) {
        n.additiveExpression.accept(this);
    }

    /**
     * multiplicativeExpression -> MultiplicativeExpression() nodeListOptional
     * -> ( "+" MultiplicativeExpression() | "-" MultiplicativeExpression() |
     * NumericLiteralPositive() | NumericLiteralNegative() )*
     */
    @Override
    public void visit(AdditiveExpression n) {
        n.multiplicativeExpression.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * unaryExpression -> UnaryExpression() nodeListOptional -> ( "*"
     * UnaryExpression() | "/" UnaryExpression() )*
     */
    @Override
    public void visit(MultiplicativeExpression n) {
        n.unaryExpression.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * nodeChoice -> ( "!" PrimaryExpression() | "+" PrimaryExpression() | "-"
     * PrimaryExpression() | PrimaryExpression() )
     */
    @Override
    public void visit(UnaryExpression n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> BrackettedExpression() | BuiltInCall() | IRIrefOrFunction()
     * | RDFLiteral() | NumericLiteral() | BooleanLiteral() | Var()
     */
    @Override
    public void visit(PrimaryExpression n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> "(" expression -> Expression() nodeToken1 -> ")"
     */
    @Override
    public void visit(BrackettedExpression n) {
        n.nodeToken.accept(this);
        n.expression.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * nodeChoice -> ( <STR> "(" Expression() ")" | <LANG> "(" Expression() ")"
     * | <LANGMATCHES> "(" Expression() "," Expression() ")" | <DATATYPE> "("
     * Expression() ")" | <BOUND> "(" Var() ")" | <SAME_TERM> "(" Expression()
     * "," Expression() ")" | <IS_IRI> "(" Expression() ")" | <IS_URI> "("
     * Expression() ")" | <IS_BLANK> "(" Expression() ")" | <IS_LITERAL> "("
     * Expression() ")" | RegexExpression() )
     */
    @Override
    public void visit(BuiltInCall n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> <REGEX> nodeToken1 -> "(" expression -> Expression()
     * nodeToken2 -> "," expression1 -> Expression() nodeOptional -> ( ","
     * Expression() )? nodeToken3 -> ")"
     */
    @Override
    public void visit(RegexExpression n) {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.expression.accept(this);
        n.nodeToken2.accept(this);
        n.expression1.accept(this);
        n.nodeOptional.accept(this);
        n.nodeToken3.accept(this);
    }

    /**
     * iRIref -> IRIref() nodeOptional -> ( ArgList() )?
     */
    @Override
    public void visit(IRIrefOrFunction n) {
        n.iRIref.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * sparqlString -> SparqlString() nodeOptional -> ( <LANGTAG> | ( "^^"
     * IRIref() ) )?
     */
    @Override
    public void visit(RDFLiteral n) {
        n.sparqlString.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * nodeChoice -> ( NumericLiteralUnsigned() | NumericLiteralPositive() |
     * NumericLiteralNegative() )
     */
    @Override
    public void visit(NumericLiteral n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <INTEGER> | <DECIMAL> | <DOUBLE>
     */
    @Override
    public void visit(NumericLiteralUnsigned n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <INTEGER_POSITIVE> | <DECIMAL_POSITIVE> | <DOUBLE_POSITIVE>
     */
    @Override
    public void visit(NumericLiteralPositive n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <INTEGER_NEGATIVE> | <DECIMAL_NEGATIVE> | <DOUBLE_NEGATIVE>
     */
    @Override
    public void visit(NumericLiteralNegative n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <TRUE> | <FALSE>
     */
    @Override
    public void visit(BooleanLiteral n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <STRING_LITERAL1> | <STRING_LITERAL2> |
     * <STRING_LITERAL_LONG1> | <STRING_LITERAL_LONG2>
     */
    @Override
    public void visit(SparqlString n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <IRI_REF> | PrefixedName()
     */
    @Override
    public void visit(IRIref n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <PNAME_LN> | <PNAME_NS>
     */
    @Override
    public void visit(PrefixedName n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeChoice -> <BLANK_NODE_LABEL> | <ANON>
     */
    @Override
    public void visit(BlankNode n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> <PUTATIVE_LITERAL>
     */
    @Override
    public void visit(PutativeLiteral n) {
        n.nodeToken.accept(this);
    }

    /**
     * prologue -> Prologue() nodeList -> ( "[" Rule() "]" )+
     */
    @Override
    public void visit(SparqlSpin n) {
        n.prologue.accept(this);
        n.nodeList.accept(this);
    }

    /**
     * consequent -> Consequent() nodeToken -> <WHERE> antecedent ->
     * Antecedent()
     */
    @Override
    public void visit(Rule n) {
        n.consequent.accept(this);
        n.nodeToken.accept(this);
        n.antecedent.accept(this);
    }

    /**
     * nodeChoice -> RuleConstructClause() | RuleModifyClause()
     */
    @Override
    public void visit(Consequent n) {
        n.nodeChoice.accept(this);
    }

    /**
     * nodeToken -> <CONSTRUCT> constructTemplate -> ConstructTemplate()
     * nodeListOptional -> ( DatasetClause() )*
     */
    @Override
    public void visit(RuleConstructClause n) {
        n.nodeToken.accept(this);
        n.constructTemplate.accept(this);
        n.nodeListOptional.accept(this);
    }

    /**
     * nodeToken -> <DELETE> deleteClause -> DeleteClause() nodeOptional -> (
     * <INSERT> InsertClause() )?
     */
    @Override
    public void visit(RuleModifyClause n) {
        n.nodeToken.accept(this);
        n.deleteClause.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * nodeToken -> "{" nodeOptional -> ( DeleteTriples() )? nodeToken1 -> "}"
     */
    @Override
    public void visit(DeleteClause n) {
        n.nodeToken.accept(this);
        n.nodeOptional.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * triplesSameSubject -> TriplesSameSubject() nodeOptional -> ( "." (
     * DeleteTriples() )? )?
     */
    @Override
    public void visit(DeleteTriples n) {
        n.triplesSameSubject.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * nodeToken -> "{" nodeOptional -> ( InsertTriples() )? nodeToken1 -> "}"
     */
    @Override
    public void visit(InsertClause n) {
        n.nodeToken.accept(this);
        n.nodeOptional.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * triplesSameSubject -> TriplesSameSubject() nodeOptional -> ( "." (
     * InsertTriples() )? )?
     */
    @Override
    public void visit(InsertTriples n) {
        n.triplesSameSubject.accept(this);
        n.nodeOptional.accept(this);
    }

    /**
     * whereClause -> WhereClause() solutionModifier -> SolutionModifier()
     */
    @Override
    public void visit(Antecedent n) {
        n.whereClause.accept(this);
        n.solutionModifier.accept(this);
    }

    /**
     * nodeToken -> <BIND> nodeToken1 -> "(" expression -> Expression()
     * nodeToken2 -> <AS> var -> Var() nodeToken3 -> ")"
     */
    @Override
    public void visit(Bind n) {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.expression.accept(this);
        n.nodeToken2.accept(this);
        n.var.accept(this);
        n.nodeToken3.accept(this);
    }

}
