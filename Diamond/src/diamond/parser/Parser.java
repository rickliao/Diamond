/* Parser.java */
/* Generated By:JavaCC: Do not edit this line. Parser.java */
package diamond.parser;

import diamond.parser.syntaxtree.*;

import java.util.Vector;

@SuppressWarnings("unused")
public class Parser implements ParserConstants {

    public static void main(String[] args) throws ParseException {
        Parser parser = new Parser(System.in);
        parser.Query();
    }

    final public Query Query() throws ParseException {
        Prologue n0;
        NodeChoice n1;
        SelectQuery n2;
        ConstructQuery n3;
        DescribeQuery n4;
        AskQuery n5;
        n0 = Prologue();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case SELECT: {
            n2 = SelectQuery();
            n1 = new NodeChoice(n2, 0);
            break;
        }
        case CONSTRUCT: {
            n3 = ConstructQuery();
            n1 = new NodeChoice(n3, 1);
            break;
        }
        case DESCRIBE: {
            n4 = DescribeQuery();
            n1 = new NodeChoice(n4, 2);
            break;
        }
        case ASK: {
            n5 = AskQuery();
            n1 = new NodeChoice(n5, 3);
            break;
        }
        default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new Query(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public Prologue Prologue() throws ParseException {
        NodeOptional n0 = new NodeOptional();
        BaseDecl n1;
        NodeListOptional n2 = new NodeListOptional();
        PrefixDecl n3;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case BASE: {
            n1 = BaseDecl();
            n0.addNode(n1);
            break;
        }
        default:
            jj_la1[1] = jj_gen;
            ;
        }
        label_1: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case PREFIX: {
                ;
                break;
            }
            default:
                jj_la1[2] = jj_gen;
                break label_1;
            }
            n3 = PrefixDecl();
            n2.addNode(n3);
        }
        n2.nodes.trimToSize();
        {
            if ("" != null)
                return new Prologue(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public BaseDecl BaseDecl() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        n1 = jj_consume_token(BASE);
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(IRI_REF);
        n2 = JTBToolkit.makeNodeToken(n3);
        {
            if ("" != null)
                return new BaseDecl(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public PrefixDecl PrefixDecl() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        NodeToken n4;
        Token n5;
        n1 = jj_consume_token(PREFIX);
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(PNAME_NS);
        n2 = JTBToolkit.makeNodeToken(n3);
        n5 = jj_consume_token(IRI_REF);
        n4 = JTBToolkit.makeNodeToken(n5);
        {
            if ("" != null)
                return new PrefixDecl(n0, n2, n4);
        }
        throw new Error("Missing return statement in function");
    }

    final public SelectQuery SelectQuery() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeOptional n2 = new NodeOptional();
        NodeChoice n3;
        NodeToken n4;
        Token n5;
        NodeToken n6;
        Token n7;
        NodeChoice n8;
        NodeList n9 = new NodeList();
        Var n10;
        NodeToken n11;
        Token n12;
        NodeListOptional n13 = new NodeListOptional();
        DatasetClause n14;
        WhereClause n15;
        SolutionModifier n16;
        n1 = jj_consume_token(SELECT);
        n0 = JTBToolkit.makeNodeToken(n1);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case DISTINCT:
        case REDUCED: {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case DISTINCT: {
                n5 = jj_consume_token(DISTINCT);
                n4 = JTBToolkit.makeNodeToken(n5);
                n3 = new NodeChoice(n4, 0);
                break;
            }
            case REDUCED: {
                n7 = jj_consume_token(REDUCED);
                n6 = JTBToolkit.makeNodeToken(n7);
                n3 = new NodeChoice(n6, 1);
                break;
            }
            default:
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            n2.addNode(n3);
            break;
        }
        default:
            jj_la1[4] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case VAR1:
        case VAR2: {
            label_2: while (true) {
                n10 = Var();
                n9.addNode(n10);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case VAR1:
                case VAR2: {
                    ;
                    break;
                }
                default:
                    jj_la1[5] = jj_gen;
                    break label_2;
                }
            }
            n9.nodes.trimToSize();
            n8 = new NodeChoice(n9, 0);
            break;
        }
        case 82: {
            n12 = jj_consume_token(82);
            n11 = JTBToolkit.makeNodeToken(n12);
            n8 = new NodeChoice(n11, 1);
            break;
        }
        default:
            jj_la1[6] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        label_3: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FROM: {
                ;
                break;
            }
            default:
                jj_la1[7] = jj_gen;
                break label_3;
            }
            n14 = DatasetClause();
            n13.addNode(n14);
        }
        n13.nodes.trimToSize();
        n15 = WhereClause();
        n16 = SolutionModifier();
        {
            if ("" != null)
                return new SelectQuery(n0, n2, n8, n13, n15, n16);
        }
        throw new Error("Missing return statement in function");
    }

    final public ConstructQuery ConstructQuery() throws ParseException {
        NodeToken n0;
        Token n1;
        ConstructTemplate n2;
        NodeListOptional n3 = new NodeListOptional();
        DatasetClause n4;
        WhereClause n5;
        SolutionModifier n6;
        n1 = jj_consume_token(CONSTRUCT);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = ConstructTemplate();
        label_4: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FROM: {
                ;
                break;
            }
            default:
                jj_la1[8] = jj_gen;
                break label_4;
            }
            n4 = DatasetClause();
            n3.addNode(n4);
        }
        n3.nodes.trimToSize();
        n5 = WhereClause();
        n6 = SolutionModifier();
        {
            if ("" != null)
                return new ConstructQuery(n0, n2, n3, n5, n6);
        }
        throw new Error("Missing return statement in function");
    }

    final public DescribeQuery DescribeQuery() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeChoice n2;
        NodeList n3 = new NodeList();
        VarOrIRIref n4;
        NodeToken n5;
        Token n6;
        NodeListOptional n7 = new NodeListOptional();
        DatasetClause n8;
        NodeOptional n9 = new NodeOptional();
        WhereClause n10;
        SolutionModifier n11;
        n1 = jj_consume_token(DESCRIBE);
        n0 = JTBToolkit.makeNodeToken(n1);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2: {
            label_5: while (true) {
                n4 = VarOrIRIref();
                n3.addNode(n4);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case IRI_REF:
                case PNAME_NS:
                case PNAME_LN:
                case VAR1:
                case VAR2: {
                    ;
                    break;
                }
                default:
                    jj_la1[9] = jj_gen;
                    break label_5;
                }
            }
            n3.nodes.trimToSize();
            n2 = new NodeChoice(n3, 0);
            break;
        }
        case 82: {
            n6 = jj_consume_token(82);
            n5 = JTBToolkit.makeNodeToken(n6);
            n2 = new NodeChoice(n5, 1);
            break;
        }
        default:
            jj_la1[10] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        label_6: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FROM: {
                ;
                break;
            }
            default:
                jj_la1[11] = jj_gen;
                break label_6;
            }
            n8 = DatasetClause();
            n7.addNode(n8);
        }
        n7.nodes.trimToSize();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case WHERE:
        case 83: {
            n10 = WhereClause();
            n9.addNode(n10);
            break;
        }
        default:
            jj_la1[12] = jj_gen;
            ;
        }
        n11 = SolutionModifier();
        {
            if ("" != null)
                return new DescribeQuery(n0, n2, n7, n9, n11);
        }
        throw new Error("Missing return statement in function");
    }

    final public AskQuery AskQuery() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeListOptional n2 = new NodeListOptional();
        DatasetClause n3;
        WhereClause n4;
        n1 = jj_consume_token(ASK);
        n0 = JTBToolkit.makeNodeToken(n1);
        label_7: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FROM: {
                ;
                break;
            }
            default:
                jj_la1[13] = jj_gen;
                break label_7;
            }
            n3 = DatasetClause();
            n2.addNode(n3);
        }
        n2.nodes.trimToSize();
        n4 = WhereClause();
        {
            if ("" != null)
                return new AskQuery(n0, n2, n4);
        }
        throw new Error("Missing return statement in function");
    }

    final public DatasetClause DatasetClause() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeChoice n2;
        DefaultGraphClause n3;
        NamedGraphClause n4;
        n1 = jj_consume_token(FROM);
        n0 = JTBToolkit.makeNodeToken(n1);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN: {
            n3 = DefaultGraphClause();
            n2 = new NodeChoice(n3, 0);
            break;
        }
        case NAMED: {
            n4 = NamedGraphClause();
            n2 = new NodeChoice(n4, 1);
            break;
        }
        default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new DatasetClause(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public DefaultGraphClause DefaultGraphClause() throws ParseException {
        SourceSelector n0;
        n0 = SourceSelector();
        {
            if ("" != null)
                return new DefaultGraphClause(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public NamedGraphClause NamedGraphClause() throws ParseException {
        NodeToken n0;
        Token n1;
        SourceSelector n2;
        n1 = jj_consume_token(NAMED);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = SourceSelector();
        {
            if ("" != null)
                return new NamedGraphClause(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public SourceSelector SourceSelector() throws ParseException {
        IRIref n0;
        n0 = IRIref();
        {
            if ("" != null)
                return new SourceSelector(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public WhereClause WhereClause() throws ParseException {
        NodeOptional n0 = new NodeOptional();
        NodeToken n1;
        Token n2;
        GroupGraphPattern n3;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case WHERE: {
            n2 = jj_consume_token(WHERE);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0.addNode(n1);
            break;
        }
        default:
            jj_la1[15] = jj_gen;
            ;
        }
        n3 = GroupGraphPattern();
        {
            if ("" != null)
                return new WhereClause(n0, n3);
        }
        throw new Error("Missing return statement in function");
    }

    final public SolutionModifier SolutionModifier() throws ParseException {
        NodeOptional n0 = new NodeOptional();
        OrderClause n1;
        NodeOptional n2 = new NodeOptional();
        LimitOffsetClauses n3;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case ORDER: {
            n1 = OrderClause();
            n0.addNode(n1);
            break;
        }
        default:
            jj_la1[16] = jj_gen;
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case LIMIT:
        case OFFSET: {
            n3 = LimitOffsetClauses();
            n2.addNode(n3);
            break;
        }
        default:
            jj_la1[17] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new SolutionModifier(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public LimitOffsetClauses LimitOffsetClauses() throws ParseException {
        NodeChoice n0;
        NodeSequence n1;
        LimitClause n2;
        NodeOptional n3 = new NodeOptional();
        OffsetClause n4;
        NodeSequence n5;
        OffsetClause n6;
        NodeOptional n7 = new NodeOptional();
        LimitClause n8;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case LIMIT: {
            n1 = new NodeSequence(2);
            n2 = LimitClause();
            n1.addNode(n2);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case OFFSET: {
                n4 = OffsetClause();
                n3.addNode(n4);
                break;
            }
            default:
                jj_la1[18] = jj_gen;
                ;
            }
            n1.addNode(n3);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case OFFSET: {
            n5 = new NodeSequence(2);
            n6 = OffsetClause();
            n5.addNode(n6);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case LIMIT: {
                n8 = LimitClause();
                n7.addNode(n8);
                break;
            }
            default:
                jj_la1[19] = jj_gen;
                ;
            }
            n5.addNode(n7);
            n0 = new NodeChoice(n5, 1);
            break;
        }
        default:
            jj_la1[20] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new LimitOffsetClauses(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public OrderClause OrderClause() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        NodeList n4 = new NodeList();
        OrderCondition n5;
        n1 = jj_consume_token(ORDER);
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(BY);
        n2 = JTBToolkit.makeNodeToken(n3);
        label_8: while (true) {
            n5 = OrderCondition();
            n4.addNode(n5);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case STR:
            case LANG:
            case LANGMATCHES:
            case DATATYPE:
            case BOUND:
            case SAME_TERM:
            case ASC:
            case DESC:
            case IS_URI:
            case IS_IRI:
            case IS_BLANK:
            case IS_LITERAL:
            case REGEX:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case VAR1:
            case VAR2:
            case 86: {
                ;
                break;
            }
            default:
                jj_la1[21] = jj_gen;
                break label_8;
            }
        }
        n4.nodes.trimToSize();
        {
            if ("" != null)
                return new OrderClause(n0, n2, n4);
        }
        throw new Error("Missing return statement in function");
    }

    final public OrderCondition OrderCondition() throws ParseException {
        NodeChoice n0;
        NodeSequence n1;
        NodeChoice n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        BrackettedExpression n7;
        NodeChoice n8;
        Constraint n9;
        Var n10;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case ASC:
        case DESC: {
            n1 = new NodeSequence(2);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case ASC: {
                n4 = jj_consume_token(ASC);
                n3 = JTBToolkit.makeNodeToken(n4);
                n2 = new NodeChoice(n3, 0);
                break;
            }
            case DESC: {
                n6 = jj_consume_token(DESC);
                n5 = JTBToolkit.makeNodeToken(n6);
                n2 = new NodeChoice(n5, 1);
                break;
            }
            default:
                jj_la1[22] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            n1.addNode(n2);
            n7 = BrackettedExpression();
            n1.addNode(n7);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case STR:
        case LANG:
        case LANGMATCHES:
        case DATATYPE:
        case BOUND:
        case SAME_TERM:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case 86: {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case STR:
            case LANG:
            case LANGMATCHES:
            case DATATYPE:
            case BOUND:
            case SAME_TERM:
            case IS_URI:
            case IS_IRI:
            case IS_BLANK:
            case IS_LITERAL:
            case REGEX:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case 86: {
                n9 = Constraint();
                n8 = new NodeChoice(n9, 0);
                break;
            }
            case VAR1:
            case VAR2: {
                n10 = Var();
                n8 = new NodeChoice(n10, 1);
                break;
            }
            default:
                jj_la1[23] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            n0 = new NodeChoice(n8, 1);
            break;
        }
        default:
            jj_la1[24] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new OrderCondition(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public LimitClause LimitClause() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        n1 = jj_consume_token(LIMIT);
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(INTEGER);
        n2 = JTBToolkit.makeNodeToken(n3);
        {
            if ("" != null)
                return new LimitClause(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public OffsetClause OffsetClause() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        n1 = jj_consume_token(OFFSET);
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(INTEGER);
        n2 = JTBToolkit.makeNodeToken(n3);
        {
            if ("" != null)
                return new OffsetClause(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public GroupGraphPattern GroupGraphPattern() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeOptional n2 = new NodeOptional();
        TriplesBlock n3;
        NodeListOptional n4 = new NodeListOptional();
        NodeSequence n5;
        GraphPatternNotTriples n6;
        NodeOptional n7;
        NodeToken n8;
        Token n9;
        NodeOptional n10;
        TriplesBlock n11;
        NodeToken n12;
        Token n13;
        n1 = jj_consume_token(83);
        n0 = JTBToolkit.makeNodeToken(n1);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
        case PUTATIVE_LITERAL:
        case 86:
        case 90: {
            n3 = TriplesBlock();
            n2.addNode(n3);
            break;
        }
        default:
            jj_la1[25] = jj_gen;
            ;
        }
        label_9: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case GRAPH:
            case OPTIONAL:
            case FILTER:
            case BIND:
            case 83: {
                ;
                break;
            }
            default:
                jj_la1[26] = jj_gen;
                break label_9;
            }
            n7 = new NodeOptional();
            n10 = new NodeOptional();
            n5 = new NodeSequence(3);
            n6 = GraphPatternNotTriples();
            n5.addNode(n6);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 84: {
                n9 = jj_consume_token(84);
                n8 = JTBToolkit.makeNodeToken(n9);
                n7.addNode(n8);
                break;
            }
            default:
                jj_la1[27] = jj_gen;
                ;
            }
            n5.addNode(n7);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case TRUE:
            case FALSE:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case BLANK_NODE_LABEL:
            case VAR1:
            case VAR2:
            case INTEGER:
            case DECIMAL:
            case DOUBLE:
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
            case STRING_LITERAL1:
            case STRING_LITERAL2:
            case STRING_LITERAL_LONG1:
            case STRING_LITERAL_LONG2:
            case NIL:
            case ANON:
            case PUTATIVE_LITERAL:
            case 86:
            case 90: {
                n11 = TriplesBlock();
                n10.addNode(n11);
                break;
            }
            default:
                jj_la1[28] = jj_gen;
                ;
            }
            n5.addNode(n10);
            n4.addNode(n5);
        }
        n4.nodes.trimToSize();
        n13 = jj_consume_token(85);
        n12 = JTBToolkit.makeNodeToken(n13);
        {
            if ("" != null)
                return new GroupGraphPattern(n0, n2, n4, n12);
        }
        throw new Error("Missing return statement in function");
    }

    final public TriplesBlock TriplesBlock() throws ParseException {
        TriplesSameSubject n0;
        NodeOptional n1 = new NodeOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        NodeOptional n5;
        TriplesBlock n6;
        n0 = TriplesSameSubject();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 84: {
            n5 = new NodeOptional();
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(84);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case TRUE:
            case FALSE:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case BLANK_NODE_LABEL:
            case VAR1:
            case VAR2:
            case INTEGER:
            case DECIMAL:
            case DOUBLE:
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
            case STRING_LITERAL1:
            case STRING_LITERAL2:
            case STRING_LITERAL_LONG1:
            case STRING_LITERAL_LONG2:
            case NIL:
            case ANON:
            case PUTATIVE_LITERAL:
            case 86:
            case 90: {
                n6 = TriplesBlock();
                n5.addNode(n6);
                break;
            }
            default:
                jj_la1[29] = jj_gen;
                ;
            }
            n2.addNode(n5);
            n1.addNode(n2);
            break;
        }
        default:
            jj_la1[30] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new TriplesBlock(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public GraphPatternNotTriples GraphPatternNotTriples() throws ParseException {
        NodeChoice n0;
        OptionalGraphPattern n1;
        GroupOrUnionGraphPattern n2;
        GraphGraphPattern n3;
        Filter n4;
        Bind n5;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case OPTIONAL: {
            n1 = OptionalGraphPattern();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case 83: {
            n2 = GroupOrUnionGraphPattern();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        case GRAPH: {
            n3 = GraphGraphPattern();
            n0 = new NodeChoice(n3, 2);
            break;
        }
        case FILTER: {
            n4 = Filter();
            n0 = new NodeChoice(n4, 3);
            break;
        }
        case BIND: {
            n5 = Bind();
            n0 = new NodeChoice(n5, 4);
            break;
        }
        default:
            jj_la1[31] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new GraphPatternNotTriples(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public OptionalGraphPattern OptionalGraphPattern() throws ParseException {
        NodeToken n0;
        Token n1;
        GroupGraphPattern n2;
        n1 = jj_consume_token(OPTIONAL);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = GroupGraphPattern();
        {
            if ("" != null)
                return new OptionalGraphPattern(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public GraphGraphPattern GraphGraphPattern() throws ParseException {
        NodeToken n0;
        Token n1;
        VarOrIRIref n2;
        GroupGraphPattern n3;
        n1 = jj_consume_token(GRAPH);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = VarOrIRIref();
        n3 = GroupGraphPattern();
        {
            if ("" != null)
                return new GraphGraphPattern(n0, n2, n3);
        }
        throw new Error("Missing return statement in function");
    }

    final public GroupOrUnionGraphPattern GroupOrUnionGraphPattern() throws ParseException {
        GroupGraphPattern n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        GroupGraphPattern n5;
        n0 = GroupGraphPattern();
        label_10: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case UNION: {
                ;
                break;
            }
            default:
                jj_la1[32] = jj_gen;
                break label_10;
            }
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(UNION);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            n5 = GroupGraphPattern();
            n2.addNode(n5);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null)
                return new GroupOrUnionGraphPattern(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public Filter Filter() throws ParseException {
        NodeToken n0;
        Token n1;
        Constraint n2;
        n1 = jj_consume_token(FILTER);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = Constraint();
        {
            if ("" != null)
                return new Filter(n0, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public Constraint Constraint() throws ParseException {
        NodeChoice n0;
        BrackettedExpression n1;
        BuiltInCall n2;
        FunctionCall n3;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 86: {
            n1 = BrackettedExpression();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case STR:
        case LANG:
        case LANGMATCHES:
        case DATATYPE:
        case BOUND:
        case SAME_TERM:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX: {
            n2 = BuiltInCall();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN: {
            n3 = FunctionCall();
            n0 = new NodeChoice(n3, 2);
            break;
        }
        default:
            jj_la1[33] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new Constraint(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public FunctionCall FunctionCall() throws ParseException {
        IRIref n0;
        ArgList n1;
        n0 = IRIref();
        n1 = ArgList();
        {
            if ("" != null)
                return new FunctionCall(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public ArgList ArgList() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeSequence n3;
        NodeToken n4;
        Token n5;
        Expression n6;
        NodeListOptional n7 = new NodeListOptional();
        NodeSequence n8;
        NodeToken n9;
        Token n10;
        Expression n11;
        NodeToken n12;
        Token n13;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case NIL: {
            n2 = jj_consume_token(NIL);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case 86: {
            n3 = new NodeSequence(4);
            n5 = jj_consume_token(86);
            n4 = JTBToolkit.makeNodeToken(n5);
            n3.addNode(n4);
            n6 = Expression();
            n3.addNode(n6);
            label_11: while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case 87: {
                    ;
                    break;
                }
                default:
                    jj_la1[34] = jj_gen;
                    break label_11;
                }
                n8 = new NodeSequence(2);
                n10 = jj_consume_token(87);
                n9 = JTBToolkit.makeNodeToken(n10);
                n8.addNode(n9);
                n11 = Expression();
                n8.addNode(n11);
                n7.addNode(n8);
            }
            n7.nodes.trimToSize();
            n3.addNode(n7);
            n13 = jj_consume_token(88);
            n12 = JTBToolkit.makeNodeToken(n13);
            n3.addNode(n12);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new ArgList(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public ConstructTemplate ConstructTemplate() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeOptional n2 = new NodeOptional();
        ConstructTriples n3;
        NodeToken n4;
        Token n5;
        n1 = jj_consume_token(83);
        n0 = JTBToolkit.makeNodeToken(n1);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
        case PUTATIVE_LITERAL:
        case 86:
        case 90: {
            n3 = ConstructTriples();
            n2.addNode(n3);
            break;
        }
        default:
            jj_la1[36] = jj_gen;
            ;
        }
        n5 = jj_consume_token(85);
        n4 = JTBToolkit.makeNodeToken(n5);
        {
            if ("" != null)
                return new ConstructTemplate(n0, n2, n4);
        }
        throw new Error("Missing return statement in function");
    }

    final public ConstructTriples ConstructTriples() throws ParseException {
        TriplesSameSubject n0;
        NodeOptional n1 = new NodeOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        NodeOptional n5;
        ConstructTriples n6;
        n0 = TriplesSameSubject();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 84: {
            n5 = new NodeOptional();
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(84);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case TRUE:
            case FALSE:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case BLANK_NODE_LABEL:
            case VAR1:
            case VAR2:
            case INTEGER:
            case DECIMAL:
            case DOUBLE:
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
            case STRING_LITERAL1:
            case STRING_LITERAL2:
            case STRING_LITERAL_LONG1:
            case STRING_LITERAL_LONG2:
            case NIL:
            case ANON:
            case PUTATIVE_LITERAL:
            case 86:
            case 90: {
                n6 = ConstructTriples();
                n5.addNode(n6);
                break;
            }
            default:
                jj_la1[37] = jj_gen;
                ;
            }
            n2.addNode(n5);
            n1.addNode(n2);
            break;
        }
        default:
            jj_la1[38] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new ConstructTriples(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public TriplesSameSubject TriplesSameSubject() throws ParseException {
        NodeChoice n0;
        NodeSequence n1;
        VarOrTerm n2;
        PropertyListNotEmpty n3;
        NodeSequence n4;
        TriplesNode n5;
        PropertyList n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
        case PUTATIVE_LITERAL: {
            n1 = new NodeSequence(2);
            n2 = VarOrTerm();
            n1.addNode(n2);
            n3 = PropertyListNotEmpty();
            n1.addNode(n3);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case 86:
        case 90: {
            n4 = new NodeSequence(2);
            n5 = TriplesNode();
            n4.addNode(n5);
            n6 = PropertyList();
            n4.addNode(n6);
            n0 = new NodeChoice(n4, 1);
            break;
        }
        default:
            jj_la1[39] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new TriplesSameSubject(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public PropertyListNotEmpty PropertyListNotEmpty() throws ParseException {
        Verb n0;
        ObjectList n1;
        NodeListOptional n2 = new NodeListOptional();
        NodeSequence n3;
        NodeToken n4;
        Token n5;
        NodeOptional n6;
        NodeSequence n7;
        Verb n8;
        ObjectList n9;
        n0 = Verb();
        n1 = ObjectList();
        label_12: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 89: {
                ;
                break;
            }
            default:
                jj_la1[40] = jj_gen;
                break label_12;
            }
            n6 = new NodeOptional();
            n3 = new NodeSequence(2);
            n5 = jj_consume_token(89);
            n4 = JTBToolkit.makeNodeToken(n5);
            n3.addNode(n4);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case TYPE_A:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case VAR1:
            case VAR2:
            case PUTATIVE_LITERAL: {
                n7 = new NodeSequence(2);
                n8 = Verb();
                n7.addNode(n8);
                n9 = ObjectList();
                n7.addNode(n9);
                n6.addNode(n7);
                break;
            }
            default:
                jj_la1[41] = jj_gen;
                ;
            }
            n3.addNode(n6);
            n2.addNode(n3);
        }
        n2.nodes.trimToSize();
        {
            if ("" != null)
                return new PropertyListNotEmpty(n0, n1, n2);
        }
        throw new Error("Missing return statement in function");
    }

    final public PropertyList PropertyList() throws ParseException {
        NodeOptional n0 = new NodeOptional();
        PropertyListNotEmpty n1;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TYPE_A:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case PUTATIVE_LITERAL: {
            n1 = PropertyListNotEmpty();
            n0.addNode(n1);
            break;
        }
        default:
            jj_la1[42] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new PropertyList(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public ObjectList ObjectList() throws ParseException {
        SparqlObject n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        SparqlObject n5;
        n0 = SparqlObject();
        label_13: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 87: {
                ;
                break;
            }
            default:
                jj_la1[43] = jj_gen;
                break label_13;
            }
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(87);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            n5 = SparqlObject();
            n2.addNode(n5);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null)
                return new ObjectList(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public SparqlObject SparqlObject() throws ParseException {
        GraphNode n0;
        n0 = GraphNode();
        {
            if ("" != null)
                return new SparqlObject(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public Verb Verb() throws ParseException {
        NodeChoice n0;
        VarOrIRIref n1;
        NodeToken n2;
        Token n3;
        PutativeLiteral n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2: {
            n1 = VarOrIRIref();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case TYPE_A: {
            n3 = jj_consume_token(TYPE_A);
            n2 = JTBToolkit.makeNodeToken(n3);
            n0 = new NodeChoice(n2, 1);
            break;
        }
        case PUTATIVE_LITERAL: {
            n4 = PutativeLiteral();
            n0 = new NodeChoice(n4, 2);
            break;
        }
        default:
            jj_la1[44] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new Verb(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public TriplesNode TriplesNode() throws ParseException {
        NodeChoice n0;
        SparqlCollection n1;
        BlankNodePropertyList n2;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 86: {
            n1 = SparqlCollection();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case 90: {
            n2 = BlankNodePropertyList();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        default:
            jj_la1[45] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new TriplesNode(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public BlankNodePropertyList BlankNodePropertyList() throws ParseException {
        NodeToken n0;
        Token n1;
        PropertyListNotEmpty n2;
        NodeToken n3;
        Token n4;
        n1 = jj_consume_token(90);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = PropertyListNotEmpty();
        n4 = jj_consume_token(91);
        n3 = JTBToolkit.makeNodeToken(n4);
        {
            if ("" != null)
                return new BlankNodePropertyList(n0, n2, n3);
        }
        throw new Error("Missing return statement in function");
    }

    final public SparqlCollection SparqlCollection() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeList n2 = new NodeList();
        GraphNode n3;
        NodeToken n4;
        Token n5;
        n1 = jj_consume_token(86);
        n0 = JTBToolkit.makeNodeToken(n1);
        label_14: while (true) {
            n3 = GraphNode();
            n2.addNode(n3);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case TRUE:
            case FALSE:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case BLANK_NODE_LABEL:
            case VAR1:
            case VAR2:
            case INTEGER:
            case DECIMAL:
            case DOUBLE:
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
            case STRING_LITERAL1:
            case STRING_LITERAL2:
            case STRING_LITERAL_LONG1:
            case STRING_LITERAL_LONG2:
            case NIL:
            case ANON:
            case PUTATIVE_LITERAL:
            case 86:
            case 90: {
                ;
                break;
            }
            default:
                jj_la1[46] = jj_gen;
                break label_14;
            }
        }
        n2.nodes.trimToSize();
        n5 = jj_consume_token(88);
        n4 = JTBToolkit.makeNodeToken(n5);
        {
            if ("" != null)
                return new SparqlCollection(n0, n2, n4);
        }
        throw new Error("Missing return statement in function");
    }

    final public GraphNode GraphNode() throws ParseException {
        NodeChoice n0;
        VarOrTerm n1;
        TriplesNode n2;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
        case PUTATIVE_LITERAL: {
            n1 = VarOrTerm();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case 86:
        case 90: {
            n2 = TriplesNode();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        default:
            jj_la1[47] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new GraphNode(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public VarOrTerm VarOrTerm() throws ParseException {
        NodeChoice n0;
        Var n1;
        GraphTerm n2;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case VAR1:
        case VAR2: {
            n1 = Var();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
        case PUTATIVE_LITERAL: {
            n2 = GraphTerm();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        default:
            jj_la1[48] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new VarOrTerm(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public VarOrIRIref VarOrIRIref() throws ParseException {
        NodeChoice n0;
        Var n1;
        IRIref n2;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case VAR1:
        case VAR2: {
            n1 = Var();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN: {
            n2 = IRIref();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        default:
            jj_la1[49] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new VarOrIRIref(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public Var Var() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case VAR1: {
            n2 = jj_consume_token(VAR1);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case VAR2: {
            n4 = jj_consume_token(VAR2);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        default:
            jj_la1[50] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new Var(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public GraphTerm GraphTerm() throws ParseException {
        NodeChoice n0;
        IRIref n1;
        RDFLiteral n2;
        NumericLiteral n3;
        BooleanLiteral n4;
        BlankNode n5;
        PutativeLiteral n6;
        NodeToken n7;
        Token n8;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN: {
            n1 = IRIref();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2: {
            n2 = RDFLiteral();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE: {
            n3 = NumericLiteral();
            n0 = new NodeChoice(n3, 2);
            break;
        }
        case TRUE:
        case FALSE: {
            n4 = BooleanLiteral();
            n0 = new NodeChoice(n4, 3);
            break;
        }
        case BLANK_NODE_LABEL:
        case ANON: {
            n5 = BlankNode();
            n0 = new NodeChoice(n5, 4);
            break;
        }
        case PUTATIVE_LITERAL: {
            n6 = PutativeLiteral();
            n0 = new NodeChoice(n6, 5);
            break;
        }
        case NIL: {
            n8 = jj_consume_token(NIL);
            n7 = JTBToolkit.makeNodeToken(n8);
            n0 = new NodeChoice(n7, 6);
            break;
        }
        default:
            jj_la1[51] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new GraphTerm(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public Expression Expression() throws ParseException {
        ConditionalOrExpression n0;
        n0 = ConditionalOrExpression();
        {
            if ("" != null)
                return new Expression(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public ConditionalOrExpression ConditionalOrExpression() throws ParseException {
        ConditionalAndExpression n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        ConditionalAndExpression n5;
        n0 = ConditionalAndExpression();
        label_15: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 92: {
                ;
                break;
            }
            default:
                jj_la1[52] = jj_gen;
                break label_15;
            }
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(92);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            n5 = ConditionalAndExpression();
            n2.addNode(n5);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null)
                return new ConditionalOrExpression(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public ConditionalAndExpression ConditionalAndExpression() throws ParseException {
        ValueLogical n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        ValueLogical n5;
        n0 = ValueLogical();
        label_16: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 93: {
                ;
                break;
            }
            default:
                jj_la1[53] = jj_gen;
                break label_16;
            }
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(93);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            n5 = ValueLogical();
            n2.addNode(n5);
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null)
                return new ConditionalAndExpression(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public ValueLogical ValueLogical() throws ParseException {
        RelationalExpression n0;
        n0 = RelationalExpression();
        {
            if ("" != null)
                return new ValueLogical(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public RelationalExpression RelationalExpression() throws ParseException {
        NumericExpression n0;
        NodeOptional n1 = new NodeOptional();
        NodeChoice n2;
        NodeSequence n3;
        NodeToken n4;
        Token n5;
        NumericExpression n6;
        NodeSequence n7;
        NodeToken n8;
        Token n9;
        NumericExpression n10;
        NodeSequence n11;
        NodeToken n12;
        Token n13;
        NumericExpression n14;
        NodeSequence n15;
        NodeToken n16;
        Token n17;
        NumericExpression n18;
        NodeSequence n19;
        NodeToken n20;
        Token n21;
        NumericExpression n22;
        NodeSequence n23;
        NodeToken n24;
        Token n25;
        NumericExpression n26;
        n0 = NumericExpression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99: {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 94: {
                n3 = new NodeSequence(2);
                n5 = jj_consume_token(94);
                n4 = JTBToolkit.makeNodeToken(n5);
                n3.addNode(n4);
                n6 = NumericExpression();
                n3.addNode(n6);
                n2 = new NodeChoice(n3, 0);
                break;
            }
            case 95: {
                n7 = new NodeSequence(2);
                n9 = jj_consume_token(95);
                n8 = JTBToolkit.makeNodeToken(n9);
                n7.addNode(n8);
                n10 = NumericExpression();
                n7.addNode(n10);
                n2 = new NodeChoice(n7, 1);
                break;
            }
            case 96: {
                n11 = new NodeSequence(2);
                n13 = jj_consume_token(96);
                n12 = JTBToolkit.makeNodeToken(n13);
                n11.addNode(n12);
                n14 = NumericExpression();
                n11.addNode(n14);
                n2 = new NodeChoice(n11, 2);
                break;
            }
            case 97: {
                n15 = new NodeSequence(2);
                n17 = jj_consume_token(97);
                n16 = JTBToolkit.makeNodeToken(n17);
                n15.addNode(n16);
                n18 = NumericExpression();
                n15.addNode(n18);
                n2 = new NodeChoice(n15, 3);
                break;
            }
            case 98: {
                n19 = new NodeSequence(2);
                n21 = jj_consume_token(98);
                n20 = JTBToolkit.makeNodeToken(n21);
                n19.addNode(n20);
                n22 = NumericExpression();
                n19.addNode(n22);
                n2 = new NodeChoice(n19, 4);
                break;
            }
            case 99: {
                n23 = new NodeSequence(2);
                n25 = jj_consume_token(99);
                n24 = JTBToolkit.makeNodeToken(n25);
                n23.addNode(n24);
                n26 = NumericExpression();
                n23.addNode(n26);
                n2 = new NodeChoice(n23, 5);
                break;
            }
            default:
                jj_la1[54] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            n1.addNode(n2);
            break;
        }
        default:
            jj_la1[55] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new RelationalExpression(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public NumericExpression NumericExpression() throws ParseException {
        AdditiveExpression n0;
        n0 = AdditiveExpression();
        {
            if ("" != null)
                return new NumericExpression(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public AdditiveExpression AdditiveExpression() throws ParseException {
        MultiplicativeExpression n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeChoice n2;
        NodeSequence n3;
        NodeToken n4;
        Token n5;
        MultiplicativeExpression n6;
        NodeSequence n7;
        NodeToken n8;
        Token n9;
        MultiplicativeExpression n10;
        NumericLiteralPositive n11;
        NumericLiteralNegative n12;
        n0 = MultiplicativeExpression();
        label_17: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
            case 100:
            case 101: {
                ;
                break;
            }
            default:
                jj_la1[56] = jj_gen;
                break label_17;
            }
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 100: {
                n3 = new NodeSequence(2);
                n5 = jj_consume_token(100);
                n4 = JTBToolkit.makeNodeToken(n5);
                n3.addNode(n4);
                n6 = MultiplicativeExpression();
                n3.addNode(n6);
                n2 = new NodeChoice(n3, 0);
                break;
            }
            case 101: {
                n7 = new NodeSequence(2);
                n9 = jj_consume_token(101);
                n8 = JTBToolkit.makeNodeToken(n9);
                n7.addNode(n8);
                n10 = MultiplicativeExpression();
                n7.addNode(n10);
                n2 = new NodeChoice(n7, 1);
                break;
            }
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE: {
                n11 = NumericLiteralPositive();
                n2 = new NodeChoice(n11, 2);
                break;
            }
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE: {
                n12 = NumericLiteralNegative();
                n2 = new NodeChoice(n12, 3);
                break;
            }
            default:
                jj_la1[57] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null)
                return new AdditiveExpression(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public MultiplicativeExpression MultiplicativeExpression() throws ParseException {
        UnaryExpression n0;
        NodeListOptional n1 = new NodeListOptional();
        NodeChoice n2;
        NodeSequence n3;
        NodeToken n4;
        Token n5;
        UnaryExpression n6;
        NodeSequence n7;
        NodeToken n8;
        Token n9;
        UnaryExpression n10;
        n0 = UnaryExpression();
        label_18: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 82:
            case 102: {
                ;
                break;
            }
            default:
                jj_la1[58] = jj_gen;
                break label_18;
            }
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 82: {
                n3 = new NodeSequence(2);
                n5 = jj_consume_token(82);
                n4 = JTBToolkit.makeNodeToken(n5);
                n3.addNode(n4);
                n6 = UnaryExpression();
                n3.addNode(n6);
                n2 = new NodeChoice(n3, 0);
                break;
            }
            case 102: {
                n7 = new NodeSequence(2);
                n9 = jj_consume_token(102);
                n8 = JTBToolkit.makeNodeToken(n9);
                n7.addNode(n8);
                n10 = UnaryExpression();
                n7.addNode(n10);
                n2 = new NodeChoice(n7, 1);
                break;
            }
            default:
                jj_la1[59] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            n1.addNode(n2);
        }
        n1.nodes.trimToSize();
        {
            if ("" != null)
                return new MultiplicativeExpression(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public UnaryExpression UnaryExpression() throws ParseException {
        NodeChoice n0;
        NodeSequence n1;
        NodeToken n2;
        Token n3;
        PrimaryExpression n4;
        NodeSequence n5;
        NodeToken n6;
        Token n7;
        PrimaryExpression n8;
        NodeSequence n9;
        NodeToken n10;
        Token n11;
        PrimaryExpression n12;
        PrimaryExpression n13;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 103: {
            n1 = new NodeSequence(2);
            n3 = jj_consume_token(103);
            n2 = JTBToolkit.makeNodeToken(n3);
            n1.addNode(n2);
            n4 = PrimaryExpression();
            n1.addNode(n4);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case 100: {
            n5 = new NodeSequence(2);
            n7 = jj_consume_token(100);
            n6 = JTBToolkit.makeNodeToken(n7);
            n5.addNode(n6);
            n8 = PrimaryExpression();
            n5.addNode(n8);
            n0 = new NodeChoice(n5, 1);
            break;
        }
        case 101: {
            n9 = new NodeSequence(2);
            n11 = jj_consume_token(101);
            n10 = JTBToolkit.makeNodeToken(n11);
            n9.addNode(n10);
            n12 = PrimaryExpression();
            n9.addNode(n12);
            n0 = new NodeChoice(n9, 2);
            break;
        }
        case STR:
        case LANG:
        case LANGMATCHES:
        case DATATYPE:
        case BOUND:
        case SAME_TERM:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX:
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case 86: {
            n13 = PrimaryExpression();
            n0 = new NodeChoice(n13, 3);
            break;
        }
        default:
            jj_la1[60] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new UnaryExpression(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public PrimaryExpression PrimaryExpression() throws ParseException {
        NodeChoice n0;
        BrackettedExpression n1;
        BuiltInCall n2;
        IRIrefOrFunction n3;
        RDFLiteral n4;
        NumericLiteral n5;
        BooleanLiteral n6;
        Var n7;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 86: {
            n1 = BrackettedExpression();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case STR:
        case LANG:
        case LANGMATCHES:
        case DATATYPE:
        case BOUND:
        case SAME_TERM:
        case IS_URI:
        case IS_IRI:
        case IS_BLANK:
        case IS_LITERAL:
        case REGEX: {
            n2 = BuiltInCall();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN: {
            n3 = IRIrefOrFunction();
            n0 = new NodeChoice(n3, 2);
            break;
        }
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2: {
            n4 = RDFLiteral();
            n0 = new NodeChoice(n4, 3);
            break;
        }
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE: {
            n5 = NumericLiteral();
            n0 = new NodeChoice(n5, 4);
            break;
        }
        case TRUE:
        case FALSE: {
            n6 = BooleanLiteral();
            n0 = new NodeChoice(n6, 5);
            break;
        }
        case VAR1:
        case VAR2: {
            n7 = Var();
            n0 = new NodeChoice(n7, 6);
            break;
        }
        default:
            jj_la1[61] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new PrimaryExpression(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public BrackettedExpression BrackettedExpression() throws ParseException {
        NodeToken n0;
        Token n1;
        Expression n2;
        NodeToken n3;
        Token n4;
        n1 = jj_consume_token(86);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = Expression();
        n4 = jj_consume_token(88);
        n3 = JTBToolkit.makeNodeToken(n4);
        {
            if ("" != null)
                return new BrackettedExpression(n0, n2, n3);
        }
        throw new Error("Missing return statement in function");
    }

    final public BuiltInCall BuiltInCall() throws ParseException {
        NodeChoice n0;
        NodeSequence n1;
        NodeToken n2;
        Token n3;
        NodeToken n4;
        Token n5;
        Expression n6;
        NodeToken n7;
        Token n8;
        NodeSequence n9;
        NodeToken n10;
        Token n11;
        NodeToken n12;
        Token n13;
        Expression n14;
        NodeToken n15;
        Token n16;
        NodeSequence n17;
        NodeToken n18;
        Token n19;
        NodeToken n20;
        Token n21;
        Expression n22;
        NodeToken n23;
        Token n24;
        Expression n25;
        NodeToken n26;
        Token n27;
        NodeSequence n28;
        NodeToken n29;
        Token n30;
        NodeToken n31;
        Token n32;
        Expression n33;
        NodeToken n34;
        Token n35;
        NodeSequence n36;
        NodeToken n37;
        Token n38;
        NodeToken n39;
        Token n40;
        Var n41;
        NodeToken n42;
        Token n43;
        NodeSequence n44;
        NodeToken n45;
        Token n46;
        NodeToken n47;
        Token n48;
        Expression n49;
        NodeToken n50;
        Token n51;
        Expression n52;
        NodeToken n53;
        Token n54;
        NodeSequence n55;
        NodeToken n56;
        Token n57;
        NodeToken n58;
        Token n59;
        Expression n60;
        NodeToken n61;
        Token n62;
        NodeSequence n63;
        NodeToken n64;
        Token n65;
        NodeToken n66;
        Token n67;
        Expression n68;
        NodeToken n69;
        Token n70;
        NodeSequence n71;
        NodeToken n72;
        Token n73;
        NodeToken n74;
        Token n75;
        Expression n76;
        NodeToken n77;
        Token n78;
        NodeSequence n79;
        NodeToken n80;
        Token n81;
        NodeToken n82;
        Token n83;
        Expression n84;
        NodeToken n85;
        Token n86;
        RegexExpression n87;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case STR: {
            n1 = new NodeSequence(4);
            n3 = jj_consume_token(STR);
            n2 = JTBToolkit.makeNodeToken(n3);
            n1.addNode(n2);
            n5 = jj_consume_token(86);
            n4 = JTBToolkit.makeNodeToken(n5);
            n1.addNode(n4);
            n6 = Expression();
            n1.addNode(n6);
            n8 = jj_consume_token(88);
            n7 = JTBToolkit.makeNodeToken(n8);
            n1.addNode(n7);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case LANG: {
            n9 = new NodeSequence(4);
            n11 = jj_consume_token(LANG);
            n10 = JTBToolkit.makeNodeToken(n11);
            n9.addNode(n10);
            n13 = jj_consume_token(86);
            n12 = JTBToolkit.makeNodeToken(n13);
            n9.addNode(n12);
            n14 = Expression();
            n9.addNode(n14);
            n16 = jj_consume_token(88);
            n15 = JTBToolkit.makeNodeToken(n16);
            n9.addNode(n15);
            n0 = new NodeChoice(n9, 1);
            break;
        }
        case LANGMATCHES: {
            n17 = new NodeSequence(6);
            n19 = jj_consume_token(LANGMATCHES);
            n18 = JTBToolkit.makeNodeToken(n19);
            n17.addNode(n18);
            n21 = jj_consume_token(86);
            n20 = JTBToolkit.makeNodeToken(n21);
            n17.addNode(n20);
            n22 = Expression();
            n17.addNode(n22);
            n24 = jj_consume_token(87);
            n23 = JTBToolkit.makeNodeToken(n24);
            n17.addNode(n23);
            n25 = Expression();
            n17.addNode(n25);
            n27 = jj_consume_token(88);
            n26 = JTBToolkit.makeNodeToken(n27);
            n17.addNode(n26);
            n0 = new NodeChoice(n17, 2);
            break;
        }
        case DATATYPE: {
            n28 = new NodeSequence(4);
            n30 = jj_consume_token(DATATYPE);
            n29 = JTBToolkit.makeNodeToken(n30);
            n28.addNode(n29);
            n32 = jj_consume_token(86);
            n31 = JTBToolkit.makeNodeToken(n32);
            n28.addNode(n31);
            n33 = Expression();
            n28.addNode(n33);
            n35 = jj_consume_token(88);
            n34 = JTBToolkit.makeNodeToken(n35);
            n28.addNode(n34);
            n0 = new NodeChoice(n28, 3);
            break;
        }
        case BOUND: {
            n36 = new NodeSequence(4);
            n38 = jj_consume_token(BOUND);
            n37 = JTBToolkit.makeNodeToken(n38);
            n36.addNode(n37);
            n40 = jj_consume_token(86);
            n39 = JTBToolkit.makeNodeToken(n40);
            n36.addNode(n39);
            n41 = Var();
            n36.addNode(n41);
            n43 = jj_consume_token(88);
            n42 = JTBToolkit.makeNodeToken(n43);
            n36.addNode(n42);
            n0 = new NodeChoice(n36, 4);
            break;
        }
        case SAME_TERM: {
            n44 = new NodeSequence(6);
            n46 = jj_consume_token(SAME_TERM);
            n45 = JTBToolkit.makeNodeToken(n46);
            n44.addNode(n45);
            n48 = jj_consume_token(86);
            n47 = JTBToolkit.makeNodeToken(n48);
            n44.addNode(n47);
            n49 = Expression();
            n44.addNode(n49);
            n51 = jj_consume_token(87);
            n50 = JTBToolkit.makeNodeToken(n51);
            n44.addNode(n50);
            n52 = Expression();
            n44.addNode(n52);
            n54 = jj_consume_token(88);
            n53 = JTBToolkit.makeNodeToken(n54);
            n44.addNode(n53);
            n0 = new NodeChoice(n44, 5);
            break;
        }
        case IS_IRI: {
            n55 = new NodeSequence(4);
            n57 = jj_consume_token(IS_IRI);
            n56 = JTBToolkit.makeNodeToken(n57);
            n55.addNode(n56);
            n59 = jj_consume_token(86);
            n58 = JTBToolkit.makeNodeToken(n59);
            n55.addNode(n58);
            n60 = Expression();
            n55.addNode(n60);
            n62 = jj_consume_token(88);
            n61 = JTBToolkit.makeNodeToken(n62);
            n55.addNode(n61);
            n0 = new NodeChoice(n55, 6);
            break;
        }
        case IS_URI: {
            n63 = new NodeSequence(4);
            n65 = jj_consume_token(IS_URI);
            n64 = JTBToolkit.makeNodeToken(n65);
            n63.addNode(n64);
            n67 = jj_consume_token(86);
            n66 = JTBToolkit.makeNodeToken(n67);
            n63.addNode(n66);
            n68 = Expression();
            n63.addNode(n68);
            n70 = jj_consume_token(88);
            n69 = JTBToolkit.makeNodeToken(n70);
            n63.addNode(n69);
            n0 = new NodeChoice(n63, 7);
            break;
        }
        case IS_BLANK: {
            n71 = new NodeSequence(4);
            n73 = jj_consume_token(IS_BLANK);
            n72 = JTBToolkit.makeNodeToken(n73);
            n71.addNode(n72);
            n75 = jj_consume_token(86);
            n74 = JTBToolkit.makeNodeToken(n75);
            n71.addNode(n74);
            n76 = Expression();
            n71.addNode(n76);
            n78 = jj_consume_token(88);
            n77 = JTBToolkit.makeNodeToken(n78);
            n71.addNode(n77);
            n0 = new NodeChoice(n71, 8);
            break;
        }
        case IS_LITERAL: {
            n79 = new NodeSequence(4);
            n81 = jj_consume_token(IS_LITERAL);
            n80 = JTBToolkit.makeNodeToken(n81);
            n79.addNode(n80);
            n83 = jj_consume_token(86);
            n82 = JTBToolkit.makeNodeToken(n83);
            n79.addNode(n82);
            n84 = Expression();
            n79.addNode(n84);
            n86 = jj_consume_token(88);
            n85 = JTBToolkit.makeNodeToken(n86);
            n79.addNode(n85);
            n0 = new NodeChoice(n79, 9);
            break;
        }
        case REGEX: {
            n87 = RegexExpression();
            n0 = new NodeChoice(n87, 10);
            break;
        }
        default:
            jj_la1[62] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new BuiltInCall(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public RegexExpression RegexExpression() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        Expression n4;
        NodeToken n5;
        Token n6;
        Expression n7;
        NodeOptional n8 = new NodeOptional();
        NodeSequence n9;
        NodeToken n10;
        Token n11;
        Expression n12;
        NodeToken n13;
        Token n14;
        n1 = jj_consume_token(REGEX);
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(86);
        n2 = JTBToolkit.makeNodeToken(n3);
        n4 = Expression();
        n6 = jj_consume_token(87);
        n5 = JTBToolkit.makeNodeToken(n6);
        n7 = Expression();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 87: {
            n9 = new NodeSequence(2);
            n11 = jj_consume_token(87);
            n10 = JTBToolkit.makeNodeToken(n11);
            n9.addNode(n10);
            n12 = Expression();
            n9.addNode(n12);
            n8.addNode(n9);
            break;
        }
        default:
            jj_la1[63] = jj_gen;
            ;
        }
        n14 = jj_consume_token(88);
        n13 = JTBToolkit.makeNodeToken(n14);
        {
            if ("" != null)
                return new RegexExpression(n0, n2, n4, n5, n7, n8, n13);
        }
        throw new Error("Missing return statement in function");
    }

    final public IRIrefOrFunction IRIrefOrFunction() throws ParseException {
        IRIref n0;
        NodeOptional n1 = new NodeOptional();
        ArgList n2;
        n0 = IRIref();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case NIL:
        case 86: {
            n2 = ArgList();
            n1.addNode(n2);
            break;
        }
        default:
            jj_la1[64] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new IRIrefOrFunction(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public RDFLiteral RDFLiteral() throws ParseException {
        SparqlString n0;
        NodeOptional n1 = new NodeOptional();
        NodeChoice n2;
        NodeToken n3;
        Token n4;
        NodeSequence n5;
        NodeToken n6;
        Token n7;
        IRIref n8;
        n0 = SparqlString();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case LANGTAG:
        case 104: {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case LANGTAG: {
                n4 = jj_consume_token(LANGTAG);
                n3 = JTBToolkit.makeNodeToken(n4);
                n2 = new NodeChoice(n3, 0);
                break;
            }
            case 104: {
                n5 = new NodeSequence(2);
                n7 = jj_consume_token(104);
                n6 = JTBToolkit.makeNodeToken(n7);
                n5.addNode(n6);
                n8 = IRIref();
                n5.addNode(n8);
                n2 = new NodeChoice(n5, 1);
                break;
            }
            default:
                jj_la1[65] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
            }
            n1.addNode(n2);
            break;
        }
        default:
            jj_la1[66] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new RDFLiteral(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public NumericLiteral NumericLiteral() throws ParseException {
        NodeChoice n0;
        NumericLiteralUnsigned n1;
        NumericLiteralPositive n2;
        NumericLiteralNegative n3;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case INTEGER:
        case DECIMAL:
        case DOUBLE: {
            n1 = NumericLiteralUnsigned();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE: {
            n2 = NumericLiteralPositive();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE: {
            n3 = NumericLiteralNegative();
            n0 = new NodeChoice(n3, 2);
            break;
        }
        default:
            jj_la1[67] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new NumericLiteral(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public NumericLiteralUnsigned NumericLiteralUnsigned() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case INTEGER: {
            n2 = jj_consume_token(INTEGER);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case DECIMAL: {
            n4 = jj_consume_token(DECIMAL);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        case DOUBLE: {
            n6 = jj_consume_token(DOUBLE);
            n5 = JTBToolkit.makeNodeToken(n6);
            n0 = new NodeChoice(n5, 2);
            break;
        }
        default:
            jj_la1[68] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new NumericLiteralUnsigned(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public NumericLiteralPositive NumericLiteralPositive() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case INTEGER_POSITIVE: {
            n2 = jj_consume_token(INTEGER_POSITIVE);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case DECIMAL_POSITIVE: {
            n4 = jj_consume_token(DECIMAL_POSITIVE);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        case DOUBLE_POSITIVE: {
            n6 = jj_consume_token(DOUBLE_POSITIVE);
            n5 = JTBToolkit.makeNodeToken(n6);
            n0 = new NodeChoice(n5, 2);
            break;
        }
        default:
            jj_la1[69] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new NumericLiteralPositive(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public NumericLiteralNegative NumericLiteralNegative() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case INTEGER_NEGATIVE: {
            n2 = jj_consume_token(INTEGER_NEGATIVE);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case DECIMAL_NEGATIVE: {
            n4 = jj_consume_token(DECIMAL_NEGATIVE);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        case DOUBLE_NEGATIVE: {
            n6 = jj_consume_token(DOUBLE_NEGATIVE);
            n5 = JTBToolkit.makeNodeToken(n6);
            n0 = new NodeChoice(n5, 2);
            break;
        }
        default:
            jj_la1[70] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new NumericLiteralNegative(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public BooleanLiteral BooleanLiteral() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TRUE: {
            n2 = jj_consume_token(TRUE);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case FALSE: {
            n4 = jj_consume_token(FALSE);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        default:
            jj_la1[71] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new BooleanLiteral(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public SparqlString SparqlString() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        NodeToken n5;
        Token n6;
        NodeToken n7;
        Token n8;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case STRING_LITERAL1: {
            n2 = jj_consume_token(STRING_LITERAL1);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case STRING_LITERAL2: {
            n4 = jj_consume_token(STRING_LITERAL2);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        case STRING_LITERAL_LONG1: {
            n6 = jj_consume_token(STRING_LITERAL_LONG1);
            n5 = JTBToolkit.makeNodeToken(n6);
            n0 = new NodeChoice(n5, 2);
            break;
        }
        case STRING_LITERAL_LONG2: {
            n8 = jj_consume_token(STRING_LITERAL_LONG2);
            n7 = JTBToolkit.makeNodeToken(n8);
            n0 = new NodeChoice(n7, 3);
            break;
        }
        default:
            jj_la1[72] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new SparqlString(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public IRIref IRIref() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        PrefixedName n3;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case IRI_REF: {
            n2 = jj_consume_token(IRI_REF);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case PNAME_NS:
        case PNAME_LN: {
            n3 = PrefixedName();
            n0 = new NodeChoice(n3, 1);
            break;
        }
        default:
            jj_la1[73] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new IRIref(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public PrefixedName PrefixedName() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case PNAME_LN: {
            n2 = jj_consume_token(PNAME_LN);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case PNAME_NS: {
            n4 = jj_consume_token(PNAME_NS);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        default:
            jj_la1[74] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new PrefixedName(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public BlankNode BlankNode() throws ParseException {
        NodeChoice n0;
        NodeToken n1;
        Token n2;
        NodeToken n3;
        Token n4;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case BLANK_NODE_LABEL: {
            n2 = jj_consume_token(BLANK_NODE_LABEL);
            n1 = JTBToolkit.makeNodeToken(n2);
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case ANON: {
            n4 = jj_consume_token(ANON);
            n3 = JTBToolkit.makeNodeToken(n4);
            n0 = new NodeChoice(n3, 1);
            break;
        }
        default:
            jj_la1[75] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new BlankNode(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public PutativeLiteral PutativeLiteral() throws ParseException {
        NodeToken n0;
        Token n1;
        n1 = jj_consume_token(PUTATIVE_LITERAL);
        n0 = JTBToolkit.makeNodeToken(n1);
        {
            if ("" != null)
                return new PutativeLiteral(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public SparqlSpin SparqlSpin() throws ParseException {
        Prologue n0;
        NodeList n1 = new NodeList();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        Rule n5;
        NodeToken n6;
        Token n7;
        n0 = Prologue();
        label_19: while (true) {
            n2 = new NodeSequence(3);
            n4 = jj_consume_token(90);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            n5 = Rule();
            n2.addNode(n5);
            n7 = jj_consume_token(91);
            n6 = JTBToolkit.makeNodeToken(n7);
            n2.addNode(n6);
            n1.addNode(n2);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 90: {
                ;
                break;
            }
            default:
                jj_la1[76] = jj_gen;
                break label_19;
            }
        }
        n1.nodes.trimToSize();
        {
            if ("" != null)
                return new SparqlSpin(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public Rule Rule() throws ParseException {
        Consequent n0;
        NodeToken n1;
        Token n2;
        Antecedent n3;
        n0 = Consequent();
        n2 = jj_consume_token(WHERE);
        n1 = JTBToolkit.makeNodeToken(n2);
        n3 = Antecedent();
        {
            if ("" != null)
                return new Rule(n0, n1, n3);
        }
        throw new Error("Missing return statement in function");
    }

    final public Consequent Consequent() throws ParseException {
        NodeChoice n0;
        RuleConstructClause n1;
        RuleModifyClause n2;
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case CONSTRUCT: {
            n1 = RuleConstructClause();
            n0 = new NodeChoice(n1, 0);
            break;
        }
        case DELETE: {
            n2 = RuleModifyClause();
            n0 = new NodeChoice(n2, 1);
            break;
        }
        default:
            jj_la1[77] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        {
            if ("" != null)
                return new Consequent(n0);
        }
        throw new Error("Missing return statement in function");
    }

    final public RuleConstructClause RuleConstructClause() throws ParseException {
        NodeToken n0;
        Token n1;
        ConstructTemplate n2;
        NodeListOptional n3 = new NodeListOptional();
        DatasetClause n4;
        n1 = jj_consume_token(CONSTRUCT);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = ConstructTemplate();
        label_20: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case FROM: {
                ;
                break;
            }
            default:
                jj_la1[78] = jj_gen;
                break label_20;
            }
            n4 = DatasetClause();
            n3.addNode(n4);
        }
        n3.nodes.trimToSize();
        {
            if ("" != null)
                return new RuleConstructClause(n0, n2, n3);
        }
        throw new Error("Missing return statement in function");
    }

    final public RuleModifyClause RuleModifyClause() throws ParseException {
        NodeToken n0;
        Token n1;
        DeleteClause n2;
        NodeOptional n3 = new NodeOptional();
        NodeSequence n4;
        NodeToken n5;
        Token n6;
        InsertClause n7;
        n1 = jj_consume_token(DELETE);
        n0 = JTBToolkit.makeNodeToken(n1);
        n2 = DeleteClause();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case INSERT: {
            n4 = new NodeSequence(2);
            n6 = jj_consume_token(INSERT);
            n5 = JTBToolkit.makeNodeToken(n6);
            n4.addNode(n5);
            n7 = InsertClause();
            n4.addNode(n7);
            n3.addNode(n4);
            break;
        }
        default:
            jj_la1[79] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new RuleModifyClause(n0, n2, n3);
        }
        throw new Error("Missing return statement in function");
    }

    final public DeleteClause DeleteClause() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeOptional n2 = new NodeOptional();
        DeleteTriples n3;
        NodeToken n4;
        Token n5;
        n1 = jj_consume_token(83);
        n0 = JTBToolkit.makeNodeToken(n1);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
        case PUTATIVE_LITERAL:
        case 86:
        case 90: {
            n3 = DeleteTriples();
            n2.addNode(n3);
            break;
        }
        default:
            jj_la1[80] = jj_gen;
            ;
        }
        n5 = jj_consume_token(85);
        n4 = JTBToolkit.makeNodeToken(n5);
        {
            if ("" != null)
                return new DeleteClause(n0, n2, n4);
        }
        throw new Error("Missing return statement in function");
    }

    final public DeleteTriples DeleteTriples() throws ParseException {
        TriplesSameSubject n0;
        NodeOptional n1 = new NodeOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        NodeOptional n5;
        DeleteTriples n6;
        n0 = TriplesSameSubject();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 84: {
            n5 = new NodeOptional();
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(84);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case TRUE:
            case FALSE:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case BLANK_NODE_LABEL:
            case VAR1:
            case VAR2:
            case INTEGER:
            case DECIMAL:
            case DOUBLE:
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
            case STRING_LITERAL1:
            case STRING_LITERAL2:
            case STRING_LITERAL_LONG1:
            case STRING_LITERAL_LONG2:
            case NIL:
            case ANON:
            case PUTATIVE_LITERAL:
            case 86:
            case 90: {
                n6 = DeleteTriples();
                n5.addNode(n6);
                break;
            }
            default:
                jj_la1[81] = jj_gen;
                ;
            }
            n2.addNode(n5);
            n1.addNode(n2);
            break;
        }
        default:
            jj_la1[82] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new DeleteTriples(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public InsertClause InsertClause() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeOptional n2 = new NodeOptional();
        InsertTriples n3;
        NodeToken n4;
        Token n5;
        n1 = jj_consume_token(83);
        n0 = JTBToolkit.makeNodeToken(n1);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case TRUE:
        case FALSE:
        case IRI_REF:
        case PNAME_NS:
        case PNAME_LN:
        case BLANK_NODE_LABEL:
        case VAR1:
        case VAR2:
        case INTEGER:
        case DECIMAL:
        case DOUBLE:
        case INTEGER_POSITIVE:
        case DECIMAL_POSITIVE:
        case DOUBLE_POSITIVE:
        case INTEGER_NEGATIVE:
        case DECIMAL_NEGATIVE:
        case DOUBLE_NEGATIVE:
        case STRING_LITERAL1:
        case STRING_LITERAL2:
        case STRING_LITERAL_LONG1:
        case STRING_LITERAL_LONG2:
        case NIL:
        case ANON:
        case PUTATIVE_LITERAL:
        case 86:
        case 90: {
            n3 = InsertTriples();
            n2.addNode(n3);
            break;
        }
        default:
            jj_la1[83] = jj_gen;
            ;
        }
        n5 = jj_consume_token(85);
        n4 = JTBToolkit.makeNodeToken(n5);
        {
            if ("" != null)
                return new InsertClause(n0, n2, n4);
        }
        throw new Error("Missing return statement in function");
    }

    final public InsertTriples InsertTriples() throws ParseException {
        TriplesSameSubject n0;
        NodeOptional n1 = new NodeOptional();
        NodeSequence n2;
        NodeToken n3;
        Token n4;
        NodeOptional n5;
        InsertTriples n6;
        n0 = TriplesSameSubject();
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 84: {
            n5 = new NodeOptional();
            n2 = new NodeSequence(2);
            n4 = jj_consume_token(84);
            n3 = JTBToolkit.makeNodeToken(n4);
            n2.addNode(n3);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case TRUE:
            case FALSE:
            case IRI_REF:
            case PNAME_NS:
            case PNAME_LN:
            case BLANK_NODE_LABEL:
            case VAR1:
            case VAR2:
            case INTEGER:
            case DECIMAL:
            case DOUBLE:
            case INTEGER_POSITIVE:
            case DECIMAL_POSITIVE:
            case DOUBLE_POSITIVE:
            case INTEGER_NEGATIVE:
            case DECIMAL_NEGATIVE:
            case DOUBLE_NEGATIVE:
            case STRING_LITERAL1:
            case STRING_LITERAL2:
            case STRING_LITERAL_LONG1:
            case STRING_LITERAL_LONG2:
            case NIL:
            case ANON:
            case PUTATIVE_LITERAL:
            case 86:
            case 90: {
                n6 = InsertTriples();
                n5.addNode(n6);
                break;
            }
            default:
                jj_la1[84] = jj_gen;
                ;
            }
            n2.addNode(n5);
            n1.addNode(n2);
            break;
        }
        default:
            jj_la1[85] = jj_gen;
            ;
        }
        {
            if ("" != null)
                return new InsertTriples(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public Antecedent Antecedent() throws ParseException {
        WhereClause n0;
        SolutionModifier n1;
        n0 = WhereClause();
        n1 = SolutionModifier();
        {
            if ("" != null)
                return new Antecedent(n0, n1);
        }
        throw new Error("Missing return statement in function");
    }

    final public Bind Bind() throws ParseException {
        NodeToken n0;
        Token n1;
        NodeToken n2;
        Token n3;
        Expression n4;
        NodeToken n5;
        Token n6;
        Var n7;
        NodeToken n8;
        Token n9;
        n1 = jj_consume_token(BIND);
        n0 = JTBToolkit.makeNodeToken(n1);
        n3 = jj_consume_token(86);
        n2 = JTBToolkit.makeNodeToken(n3);
        n4 = Expression();
        n6 = jj_consume_token(AS);
        n5 = JTBToolkit.makeNodeToken(n6);
        n7 = Var();
        n9 = jj_consume_token(88);
        n8 = JTBToolkit.makeNodeToken(n9);
        {
            if ("" != null)
                return new Bind(n0, n2, n4, n5, n7, n8);
        }
        throw new Error("Missing return statement in function");
    }

    /** Generated Token Manager. */
    public ParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /** Current token. */
    public Token token;
    /** Next token. */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[86];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;
    static private int[] jj_la1_3;
    static {
        jj_la1_init_0();
        jj_la1_init_1();
        jj_la1_init_2();
        jj_la1_init_3();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[] { 0xf000, 0x400, 0x800, 0x300000, 0x300000, 0x0, 0x0, 0x400000, 0x400000, 0x0, 0x0,
                0x400000, 0x1000000, 0x400000, 0x800000, 0x1000000, 0x10000, 0xc0000, 0x80000, 0x40000, 0xc0000,
                0xe0000000, 0x0, 0xe0000000, 0xe0000000, 0x0, 0x16000000, 0x0, 0x0, 0x0, 0x0, 0x16000000, 0x8000000,
                0xe0000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0000000, 0xe0000000, 0xe0000000, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2000, 0x400000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0xc00000, 0xc00000, 0x0, 0x0, 0xdc0000, 0xdc0000, 0x0, 0x0,
                0x0, 0x1c0000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xdc03ff, 0x18, 0xdc03e7, 0xdc03ff, 0xfefc0c00, 0x4000,
                0x0, 0xfefc0c00, 0xfefc0c00, 0x0, 0x4000, 0x0, 0x1c03e7, 0x0, 0x0, 0xfefc0c00, 0xfefc0c00, 0x0,
                0xfefc0c00, 0x0, 0xdd0000, 0xdd0000, 0x0, 0xdd0000, 0x0, 0xfefc0c00, 0xfefc0c00, 0xfefc0c00, 0xdc0000,
                0xc00000, 0xfe3c0c00, 0x0, 0x0, 0x0, 0x0, 0xf0000000, 0xf0000000, 0x0, 0x0, 0xfedc0fe7, 0xfedc0fe7,
                0x3e7, 0x0, 0x0, 0x1000000, 0x1000000, 0xfe000000, 0xe000000, 0x70000000, 0x80000000, 0xc00, 0x0,
                0x1c0000, 0x180000, 0x200000, 0x0, 0x2000, 0x0, 0x1000, 0xfefc0c00, 0xfefc0c00, 0x0, 0xfefc0c00,
                0xfefc0c00, 0x0, };
    }

    private static void jj_la1_init_2() {
        jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000, 0x0, 0x0, 0x0, 0x40000, 0x0, 0x80000, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x400000, 0x0, 0x400000, 0x400000, 0x442057b, 0x80000, 0x100000,
                0x442057b, 0x442057b, 0x100000, 0x80000, 0x0, 0x400000, 0x800000, 0x400100, 0x442057b, 0x442057b,
                0x100000, 0x442057b, 0x2000000, 0x20000, 0x20000, 0x800000, 0x20000, 0x4400000, 0x442057b, 0x442057b,
                0x2057b, 0x0, 0x0, 0x2057b, 0x10000000, 0x20000000, 0xc0000000, 0xc0000000, 0x3, 0x3, 0x40000, 0x40000,
                0x40007b, 0x40007b, 0x0, 0x800000, 0x400100, 0x0, 0x0, 0x3, 0x0, 0x0, 0x3, 0x0, 0x78, 0x0, 0x0, 0x400,
                0x4000000, 0x0, 0x0, 0x0, 0x442057b, 0x442057b, 0x100000, 0x442057b, 0x442057b, 0x100000, };
    }

    private static void jj_la1_init_3() {
        jj_la1_3 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf, 0x30,
                0x30, 0x40, 0x40, 0xb0, 0x0, 0x0, 0x0, 0x0, 0x100, 0x100, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    /** Constructor with InputStream. */
    public Parser(java.io.InputStream stream) {
        this(stream, null);
    }

    /** Constructor with InputStream and supplied encoding */
    public Parser(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new ParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 86; i++)
            jj_la1[i] = -1;
    }

    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 86; i++)
            jj_la1[i] = -1;
    }

    /** Constructor. */
    public Parser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 86; i++)
            jj_la1[i] = -1;
    }

    /** Reinitialise. */
    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 86; i++)
            jj_la1[i] = -1;
    }

    /** Constructor with generated Token Manager. */
    public Parser(ParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 86; i++)
            jj_la1[i] = -1;
    }

    /** Reinitialise. */
    public void ReInit(ParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 86; i++)
            jj_la1[i] = -1;
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    /** Get the next Token. */
    final public Token getNextToken() {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /** Get the specific Token. */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk_f() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /** Generate ParseException. */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[105];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 86; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & (1 << j)) != 0) {
                        la1tokens[96 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 105; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /** Enable tracing. */
    final public void enable_tracing() {
    }

    /** Disable tracing. */
    final public void disable_tracing() {
    }

}

@SuppressWarnings("rawtypes")
class JTBToolkit {

    @SuppressWarnings("unchecked")
    static NodeToken makeNodeToken(Token t) {
        NodeToken node = new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn);

        if (t.specialToken == null)
            return node;

        Vector temp = new Vector();

        while (t.specialToken != null) {
            t = t.specialToken;
            temp.addElement(new NodeToken(t.image.intern(), t.kind, t.beginLine, t.beginColumn, t.endLine, t.endColumn));
        }

        // Reverse the special token list
        for (int i = temp.size() - 1; i >= 0; --i)
            node.addSpecial((NodeToken) temp.elementAt(i));

        node.trimSpecials();
        return node;
    }
}
